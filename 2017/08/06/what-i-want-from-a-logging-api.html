<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>What I want from a logging API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.99.0/css/materialize.min.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link rel="stylesheet" href="/css/main.css">

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Between a rock and a crazy place">
    <link rel="alternate" type="application/rss+xml" href="/rss.xml" title="Between a rock and a crazy place">
    <link rel="alternate" type="application/json" href="/feed.json" title="Between a rock and a crazy place" >
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
	<meta name="author" content="Axel Wagner">
	<meta name="keywords" content="golang,programming">
  </head>
  <body>
    <header class="green darken-4 z-depth-2 valign-wrapper">
	  <h3><a class="white-text" href="/">Between a rock and a crazy place</a></h1>
    </header>

    <main class="container">
      <h3>What I want from a logging API</h3>
<p>2017-08-06</p>

<article>
<p><em>This is intended as an <a href="https://github.com/golang/go/wiki/ExperienceReports">Experience
Report</a> about logging in
Go. There are many like it but this one is mine.</em></p>

<p>I have been trying for a while now to find (or build) a logging API in Go that
fills my needs. There are several things that make this hard to get &quot;right&quot;
though. This is my attempt to describe them coherently in one place.</p>

<p>When I say &quot;logging&quot;, I mean informational text messages for human consumption
used to debug a specific problem. There is an idea currently gaining traction
in the Go community called &quot;structured logging&quot;.
<a href="https://github.com/sirupsen/logrus">logrus</a> is a popular package that
implements this idea. If you haven&#39;t heard of it, you might want to skim its
README. And while I definitely agree that log-messages should
contain some structural information that is useful for later filtering (like
the current time or a request ID), I believe the idea as often advocated is
somewhat misguided and conflates different use cases that are better addressed
otherwise. For example, if you are tempted to add a structured field to your
log containing an HTTP response code to alert on too many errors, you probably
want to use <a href="https://landing.google.com/sre/book/chapters/practical-alerting.html">metrics and
timeseries</a>
instead. If you want to follow a field through a variety of systems, you
probably want to <a href="https://research.google.com/pubs/pub36356.html">annotate a
trace</a>. If you want analytics
like calculating daily active users or what used user-agents are used how
often, you probably want what I like to call <a href="https://research.google.com/pubs/pub36632.html">request
annotations</a>, as these are
properties of a request, not of a log-line. If you exclude all these use cases,
there isn&#39;t a lot left for structured logging to address.</p>

<p>The logs I am talking about is to give a user or the operator of a software
more insight into what is going on under the covers. The default assumption is,
that they are not looked at until something goes wrong: Be it a test failing,
an alerting system notifying of an issue or a bug report being investigated or
a CLI not doing what the user expected. As such it is important that they are
verbose to a certain degree. As an operator, I don&#39;t want to find out that I
can&#39;t troubleshoot a problem because someone did not log a critical piece of
information. An API that requires (or encourages) me to only log structured
data will ultimately only discourage me from logging at all. In the end, some
form of <code>log.Debugf(&quot;Error reading foo: %v&quot;, err)</code> is the perfect API for my use
case. Any structured information needed to make this call practically useful
should be part of the setup phase of whatever <code>log</code> is.</p>

<p>The next somewhat contentious question is whether or not the API should support
log levels (and if so, which). My personal short answer is &quot;yes and the log
levels should be Error, Info and Debug&quot;. I could try and justify these specific
choices but I don&#39;t think that really helps; chalk it up to personal
preference if you like. I believe having <em>some</em> variation on the
verbosity of logs is very important. A CLI should be quiet by default but be
able to tell the user more specifically where things went wrong on request. A
service should be debuggable in depth, but unconditionally logging verbosely
would have in unacceptable latency impact in production and too heavy storage
costs. There need to be <em>some</em> logs by default though, to get quick insights
during an emergency or in retrospect. So, those three levels seem fine to me.</p>

<p>Lastly what I need from a logging API, is the possibility to set up verbosity
and log sinks both horizontally <em>and</em> vertically. What I mean by that is that
software is usually build in layers. They could be individual microservices,
Go packages or types. Requests will then traverse these layers vertically,
possibly branching out and interleaved to various degrees.</p>

<p><img src="/assets/request_forest.svg" alt="Request forest"></p>

<p>Depending on what and how I am debugging, it makes sense to increase the log
verbosity of a particular layer (say I narrowed down the problem to shared
state in a particular handler and want to see what happens to that state during
multiple requests) or for a particular request (say, I narrowed down a problem
to &quot;requests which have header FOO set to BAR&quot; and want to follow one of them
to get a detailed view of what it does). Same with logging sinks, for example,
a request initiated by a test should get logged to its <code>*testing.T</code> with
maximum verbosity, so that I get a detailed context about it if and only if the
test fails to immediately start debugging. These settings should be possible
during runtime without a restart. If I am debugging a production issue, I
don&#39;t want to change a command line flag and restart the service.</p>

<p>Let&#39;s try to implement such an API.</p>

<p>We can first narrow down the design space a bit, because we want to use
<code>testing.T</code> as a logging sink. A <code>T</code> has several methods that would suit our
needs well, most notably <a href="http://godoc.org/testing#T.Logf">Logf</a>. This suggest
an interface for logging sinks that looks somewhat like this:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">simpleLogger</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">simpleLogger</span><span class="p">)</span> <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">w</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">v</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewLogger</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">Logger</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">simpleLogger</span><span class="p">{</span><span class="nx">w</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This has the additional advantage, that we can add easily implement a
Discard-sink, that has minimal overhead (not even the allocations of
formatting the message):</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">Discard</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">Discard</span><span class="p">)</span> <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{}</span>
</code></pre></div>
<p>The next step is to get leveled logging. The easiest way to achieve this is
probably</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">Logs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Debug</span> <span class="nx">Logger</span>
    <span class="nx">Info</span> <span class="nx">Logger</span>
    <span class="nx">Error</span> <span class="nx">Logger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">DiscardAll</span><span class="p">()</span> <span class="nx">Logs</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Logs</span><span class="p">{</span>
        <span class="nx">Debug</span><span class="p">:</span> <span class="nx">Discard</span><span class="p">{},</span>
        <span class="nx">Info</span><span class="p">:</span> <span class="nx">Discard</span><span class="p">{},</span>
        <span class="nx">Error</span><span class="p">:</span> <span class="nx">Discard</span><span class="p">{},</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>By putting a struct like this (or its constituent fields) as members of a
handler, type or package, we can get the horizontal configurability we are
interested in.</p>

<p>To get vertical configurability we can use
<a href="http://godoc.org/context#Context.Value">context.Value</a> - as much as it&#39;s
frowned upon by some, it is the canonical way to get request-scoped
behavior/data in Go. So, let&#39;s add this to our API:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">ctxLogs</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nx">WithLogs</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">l</span> <span class="nx">Logs</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">context</span><span class="p">.</span><span class="nx">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ctxLogs</span><span class="p">{},</span> <span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">GetLogs</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">def</span> <span class="nx">Logs</span><span class="p">)</span> <span class="nx">Logs</span> <span class="p">{</span>
    <span class="c1">// If no Logs are in the context, we default to its zero-value,</span>
    <span class="c1">// by using the ,ok version of a type-assertion and throwing away</span>
    <span class="c1">// the ok.</span>
    <span class="nx">l</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Value</span><span class="p">(</span><span class="nx">ctxLogs</span><span class="p">{}).(</span><span class="nx">Logs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Debug</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">Debug</span> <span class="p">=</span> <span class="nx">def</span><span class="p">.</span><span class="nx">Debug</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Info</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">Info</span> <span class="p">=</span> <span class="nx">def</span><span class="p">.</span><span class="nx">Info</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Error</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">Error</span> <span class="p">=</span> <span class="nx">def</span><span class="p">.</span><span class="nx">Error</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>
</code></pre></div>
<p>So far, this is a sane, simple and easy to use logging API. For example:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">type</span> <span class="nx">App</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">L</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Logs</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">App</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">res</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">l</span> <span class="o">:=</span> <span class="nx">log</span><span class="p">.</span><span class="nx">GetLogs</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Context</span><span class="p">(),</span> <span class="nx">a</span><span class="p">.</span><span class="nx">L</span><span class="p">)</span>
    <span class="nx">l</span><span class="p">.</span><span class="nx">Debug</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="s">&quot;%s %s&quot;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
<p>The issue with this API, however, is that it is completely inflexible, if we
want to preserve useful information like the file and line number of the
caller. Say, I want to implement the equivalent of
<a href="http://godoc.org/io#MultiWriter">io.MultiWriter</a>. For example, I want to write
logs both to <code>os.Stderr</code> and to a file and to a network log service.</p>

<p>I might try to implement that via</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="kd">func</span> <span class="nx">MultiLogger</span><span class="p">(</span><span class="nx">ls</span> <span class="o">...</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Logger</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">multiLog</span><span class="p">{</span><span class="nx">ls</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">multiLog</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">loggers</span> <span class="p">[]</span><span class="nx">Logger</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">multiLog</span><span class="p">)</span> <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nx">loggers</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">v</span><span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>However, now the caller of <code>Logf</code> of the individual loggers will be the line in
<code>(*multiLog).Logf</code>, <em>not</em> the line of its caller. Thus, caller information will
be useless. There are two APIs currently existing in the stdlib to work around this:</p>

<ol>
<li><a href="https://tip.golang.org/pkg/testing/#T.Helper">(testing.T).Helper</a> (from
Go 1.9) lets you mark a frame as a test-helper. When the caller-information
is then added to the log-output, all frames marked as a helper is skipped.
So, theoretically, we could add a <code>Helper</code> method to our Logger interface
and require that to be called in each wrapper. However, <code>Helper</code> <em>itself</em>
uses the same caller-information. So all wrappers must call the <code>Helper</code>
method of the <em>underlying `</em>testing.T`*, without any wrapping methods. Even
embedding doesn&#39;t help, as the Go compiler creates an <a href="https://play.golang.org/p/Z8MHOrGAAt">implicit wrapper</a>
for that.</li>
<li><a href="http://godoc.org/log#Logger.Output">(log.Logger).Output</a> lets you
specify a number of call-frames to skip. We could add a similar method to
our log sink interface. And wrapping loggers would then need to increment
the passed in number, when calling a wrapped sink. It&#39;s possible to do this,
but it wouldn&#39;t help with test-logs.</li>
</ol>

<p>This is a very similar problem to the ones I wrote about
<a href="https://blog.merovius.de//2017/07/30/the-trouble-with-optional-interfaces.html">last week</a>.
For now, I am using the technique I described as <a href="https://blog.merovius.de//2017/07/30/the-trouble-with-optional-interfaces.html#extraction-methods">Extraction
Methods</a>.
That is, the modified API is now this:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span></span><span class="c1">// Logger is a logging sink.</span>
<span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Logf logs a text message with the given format and values to the sink.</span>
    <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>

    <span class="c1">// Helpers returns a list of Helpers to call into from all helper methods,</span>
    <span class="c1">// when wrapping this Logger. This is used to skip frames of logging</span>
    <span class="c1">// helpers when determining caller information.</span>
    <span class="nx">Helpers</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Helper</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Helper</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Helper marks the current frame as a helper method. It is then skipped</span>
    <span class="c1">// when determining caller information during logging.</span>
    <span class="nx">Helper</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Callers can be used as a Helper for log sinks who want to log caller</span>
<span class="c1">// information. An empty Callers is valid and ready for use.</span>
<span class="kd">type</span> <span class="nx">Callers</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// Helper marks the calling method as a helper. When using Callers in a</span>
<span class="c1">// Logger, you should also call this to mark your methods as helpers.</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Callers</span><span class="p">)</span> <span class="nx">Helper</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Caller</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span>
    <span class="nx">File</span> <span class="kt">string</span>
    <span class="nx">Line</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Caller can be used to determine the caller of Logf in a Logger, skipping all</span>
<span class="c1">// frames marked via Helper.</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Callers</span><span class="p">)</span> <span class="nx">Caller</span><span class="p">()</span> <span class="nx">Caller</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// TestingT is a subset of the methods of *testing.T, so that this package</span>
<span class="c1">// doesn&#39;t need to import testing.</span>
<span class="kd">type</span> <span class="nx">TestingT</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nx">Helper</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Testing returns a Logger that logs to t. Log lines are discarded, if the</span>
<span class="c1">// test succeeds.</span>
<span class="kd">func</span> <span class="nx">Testing</span><span class="p">(</span><span class="nx">t</span> <span class="nx">TestingT</span><span class="p">)</span> <span class="nx">Logger</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">testLogger</span><span class="p">{</span><span class="nx">t</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">testLogger</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="nx">TestingT</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">testLogger</span><span class="p">)</span> <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">l</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">Helper</span><span class="p">()</span>
    <span class="nx">l</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">v</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="nx">testLogger</span><span class="p">)</span> <span class="nx">Helpers</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Helper</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span><span class="nx">Helper</span><span class="p">{</span><span class="nx">l</span><span class="p">.</span><span class="nx">t</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// New returns a logger writing to w, prepending caller-information.</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="nx">Logger</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">simple</span><span class="p">{</span><span class="nx">w</span><span class="p">,</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Callers</span><span class="p">)}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">simple</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
    <span class="nx">c</span> <span class="o">*</span><span class="nx">Callers</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">simple</span><span class="p">)</span> <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">l</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">Helper</span><span class="p">()</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">Caller</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;%s:%d: &quot;</span> <span class="o">+</span> <span class="nx">format</span><span class="p">,</span> <span class="nb">append</span><span class="p">([]</span><span class="kd">interface</span><span class="p">{}{</span><span class="nx">c</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Line</span><span class="p">},</span> <span class="nx">v</span><span class="o">...</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">simple</span><span class="p">)</span> <span class="nx">Helpers</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Helper</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span><span class="nx">Helper</span><span class="p">{</span><span class="nx">l</span><span class="p">.</span><span class="nx">c</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Discard discards all logs.</span>
<span class="kd">func</span> <span class="nx">Discard</span><span class="p">()</span> <span class="nx">Logger</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">discard</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">discard</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">Discard</span><span class="p">)</span> <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">Discard</span><span class="p">)</span> <span class="nx">Helpers</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Helper</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// MultiLogger duplicates all Logf-calls to a list of loggers.</span>
<span class="kd">func</span> <span class="nx">MultiLogger</span><span class="p">(</span><span class="nx">ls</span> <span class="o">...</span><span class="nx">Logger</span><span class="p">)</span> <span class="nx">Logger</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">m</span> <span class="nx">multiLogger</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ls</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">helpers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">helpers</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">Helpers</span><span class="p">()</span><span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">loggers</span> <span class="p">=</span> <span class="nx">ls</span>
    <span class="k">return</span> <span class="nx">m</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">multiLogger</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">loggers</span> <span class="p">[]</span><span class="nx">Logger</span>
    <span class="nx">helpers</span> <span class="p">[]</span><span class="nx">Helper</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">multiLogger</span><span class="p">)</span> <span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">h</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nx">helpers</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">Helper</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nx">loggers</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">Logf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">v</span><span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">multiLogger</span><span class="p">)</span> <span class="nx">Helpers</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Helper</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">helpers</span>
<span class="p">}</span>
</code></pre></div>
<p>It&#39;s a kind of clunky API and I have no idea about the performance implications
of all the Helper-code.  But it <em>does</em> work, so it is, what I ended up with for
now.  Notably, it puts the implementation complexity into the <em>implementers</em> of
Logger, in favor of making the actual consumers of them as simple as possible.</p>

</article>

    </main>

    <footer class="page-footer green darken-4 white-text text-lighten-2">
      <div class="row">
        <div class="col offset-l2 l4">
          <h5>Axel Wagner</h5>
          <p class="grey-text text-lighten-4">
		    SRE, Go programmer, Mathematician.
          </p>
		  <p class="grey-text text-lighten-4">
		  	All opinions expressed are my own.
	      </p>
        </div>
        <div class="col l4">
          <ul>
            <li><a class="grey-text text-lighten-4" href="https://github.com/Merovius">github.com/Merovius</a></li>
            <li><a class="grey-text text-lighten-4" href="https://twitter.com/TheMerovius">@TheMerovius</a></li>
            <li><a class="grey-text text-lighten-4" href="https://plus.google.com/104026434400286502583">+Axel Wagner</a></li>
            <li><a class="grey-text text-lighten-4" href="/impressum.html">Impressum</a></li>
          </ul>
      </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.99.0/js/materialize.min.js"></script>
  </body>
</html>
