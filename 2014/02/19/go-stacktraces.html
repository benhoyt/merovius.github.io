<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>go stacktraces</title>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="/css/main.css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="alternate" type="application/rss+xml" href="/rss.xml" title="RSS feed">
        <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js">
</script>
    </head>
    <body>
        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Between a rock and a crazy place</a></h1>
          </div>

          <h2>go stacktraces</h2>
<p class="meta">19 Feb 2014</p>

<article class="post">
<p>Let&#39;s say you write a library in <a href="http://golang.org/">go</a> and want an easy way
to get debugging information from your users. Sure, you return <code>error</code>s from
everything, but it is sometimes hard to pinpoint where a particular error
occured and what caused it. If your package <code>panic</code>s, that will give you a
stacktrace, but as you probably know you shouldn&#39;t <code>panic</code> in case of an error,
but just gracefull recover and return the error to your caller.</p>

<p>I recently discovered a pattern which I am quite happy with (for now). You can
include a stacktrace when returning an error. If you disable this behaviour by
default you should have as good as no impact for normal users, while making it
much easier to debug problems. Neat.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">package awesomelib

import (
    &quot;os&quot;
    &quot;runtime&quot;
)

type tracedError struct {
    err   error
    trace string
}

var (
    stacktrace bool
    traceSize = 16*1024
)

func init() {
    if os.Getenv(&quot;AWESOMELIB_ENABLE_STACKTRACE&quot;) == &quot;true&quot; {
        stacktrace = true
    }
}

func wrapErr(err error) error {
    // If stacktraces are disabled, we return the error as is
    if !stacktrace {
        return err
    }

    // This is a convenience, so that we can just throw a wrapErr at every
    // point we return an error and don&#39;t get layered useless wrappers
    if Err, ok := err.(*tracedError); ok {
        return Err
    }

    buf := make([]byte, traceSize)
    n := runtime.Stack(buf, false)
    return &amp;tracedError{ err: err, trace: string(buf[:n]) }
}

func (err *tracedError) Error() string {
    return fmt.Sprintf(&quot;%v\n%s&quot;, err.err, err.trace)
}

func DoFancyStuff(path string) error {
    file, err := os.Open(path)
    if err != nil {
        return wrapErr(err)
    }
    // fancy stuff
}
</code></pre></div>
<!--

-->
</article>


          <div class="footer">
            <div class="contact">
              <p>
                Axel Wagner<br />
                Mathemematician, programmer, crazy person<br />
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/Merovius">github.com/Merovius</a><br />
				<a href="https://twitter.com/TheMerovius">@TheMerovius</a><br />
                <a href="https://plus.google.com/104026434400286502583">+Axel Wagner</a><br />
                <a href="/impressum.html">Impressum</a><br />
              </p>
            </div>
          </div>
        </div>
    </body>
</html>
