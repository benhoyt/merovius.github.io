<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Applying permutation in constant space (and linear time)</title>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="/css/main.css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="alternate" type="application/rss+xml" href="/rss.xml" title="RSS feed">
        <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js">
</script>
    </head>
    <body>
        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Between a rock and a crazy place</a></h1>
          </div>

          <h2>Applying permutation in constant space (and linear time)</h2>
<p class="meta">12 Aug 2014</p>

<article class="post">
<p>I stumbled upon a mildly interesting problem yesterday: Given an Array a and a
permutation p, apply the permutation (in place) to the Array, using only O(1)
extra space.  So, if b is the array after the algorithm, we want that
<code>a[i] == b[p[i]]</code>.</p>

<p>Naively, we would solve our problem by doing something like this (I&#39;m using go
here):</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Naive</span><span class="p">(</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">perm</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vals</span><span class="p">)</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">[</span><span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>This solves the problem in O(n) time, but it uses of course O(n) extra space
for the result array. Note also, that it does not really work in place, we have
to copy the result back.</p>

<p>The simplest iteration of this, would be to simply use a sorting-algorithm of
our choice, but use as a sorting key not the value of the elements, but the
position of the corresponding field in the permutation array:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&quot;sort&quot;</span>

<span class="kd">type</span> <span class="nx">PermSorter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">vals</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">perm</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">PermSorter</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">PermSorter</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">PermSorter</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Sort</span><span class="p">(</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">perm</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">PermSorter</span><span class="p">{</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">perm</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div>
<p>This appears a promising idea at first, but as it turns out, this doesn&#39;t
<em>really</em> use constant space after all (at least not generally). The go sort
package uses introsort internally, which is a combination of quick- and
heapsort, the latter being chosen if the recursion-depth of quicksort exceeds a
limit in O(log(n)). Thus it uses actually O(log(n)) auxiliary space. Also, the
running time of sorting is O(n log(n)) and while time complexity wasn&#39;t part of
the initially posed problem, it would actually nice to have linear running
time, if possible.</p>

<p>Note also another point: The above implementation sorts perm, thus destroying
the permutation array. Also not part of the original problem, this might pose
problems if we want to apply the same permutation to multiple arrays. We can
rectify that in this case by doing the following:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">NDPermSorter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">vals</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">perm</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">NDPermSorter</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">NDPermSorter</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="p">&lt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">perm</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">NDPermSorter</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NDSort</span><span class="p">(</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">perm</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">NDPermSorter</span><span class="p">{</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">perm</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div>
<p>But note, that this only works, because we want to sort an array of consecutive
integers. In general, we don&#39;t want to do that. And I am unaware of a solution
that doesn&#39;t have this problem (though I also didn&#39;t think about it a lot).</p>

<p>The solution of solving this problem in linear time lies in a simple
observation: If we start at any index and iteratively jump to the <em>target</em>
index of the current one, we will trace out a cycle. If any index is not in the
cycle, it will create another cycle and both cycles will be disjoint. For
example the permutation</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">i    0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19
p[i] 2  13 1  5  3  15 14 12 8  10 4  19 16 11 9  7  18 6  17 0
</code></pre></div>
<p>will create the following set of cycles:
<br>
<a href="/assets/permutation.svg"><img src="/assets/permutation.svg" style="width:100%;margin:auto;display:block;"></a></p>

<p>So the idea is to resolve every cycle separately, by iterating over the indices
and moving every element to the place it belongs:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Cycles</span><span class="p">(</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">perm</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vals</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">v</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">!=</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
            <span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">i</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This obviously only needs O(1) space. The secret, why it also only uses O(n)
time lies in the fact, that the inner loop will not be entered for elements,
that are already at the correct position. Thus this is (from a complexity
standpoint at least) the optimal solution to the problem, as it is impossible
to use <em>less</em> than linear time for applying a permutation.</p>

<p>There is still one small problem with this solution: It also sorts the
permutation array. We need this, to know when a position is already occupied by
it&#39;s final element. In our algorithm this is represented by the fact, that the
permutation is equal to it&#39;s index at that point. But really, it would be nice
if we could mark the index <em>without</em> losing the order of the permutation. But
that is not hard either - because every index is non-negative, we can
simply negate every index we are done with. This will make a negative index out
of it and we can check for that if we encounter it later and skip it in this
case. After we are done, we only need to take care to flip everything back and
all should be fine:</p>
<div class="highlight"><pre><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">NDCycles</span><span class="p">(</span><span class="nx">vals</span><span class="p">,</span> <span class="nx">perm</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">vals</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// already correct - unmark and go on</span>
            <span class="c1">// (note that ^a is the bitwise negation</span>
            <span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">^</span><span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="k">continue</span>
        <span class="p">}</span>

        <span class="nx">v</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">perm</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">!=</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">vals</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
            <span class="c1">// When we find this element in the future, we must not swap it any</span>
            <span class="c1">// further, so we mark it here</span>
            <span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">j</span> <span class="p">=</span> <span class="p">^</span><span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">perm</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="nx">vals</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Here we only mark the elements we will again encounter in the <em>future</em>. The
current index will always be unmarked, once we are done with the outer loop.</p>

<p>I am aware, that this is technically cheating; This solution relies on the
fact, that the upper-most bit of the permutation elements won&#39;t ever be set.
Thus, we actually <em>do</em> have O(n) auxiliary space (as in n bit), because these
bits are not necessary for the algorithm. However, since it is pretty unlikely,
that we will find an architecture where this is not possible (and go guarantees
us that it actually is, because len(vals) is <em>always</em> signed, so we cant have
arrays that are big enough for the msb being set anyway), I think I am okay
with it ;)</p>

<p>I ran sum Benchmarks on this an these are the figures I came up with:</p>

<table>
    <tr>
        <th>n</th>
        <td>10</td>
        <td>100</td>
        <td>1000</td>
        <td>10000</td>
    </tr>
    <tr>
        <th>Naive</th>
        <td>332 ns</td>
        <td>883 ns</td>
        <td>15046 ns</td>
        <td>81800 ns</td>
    </tr>
    <tr>
        <th>NDCycle</th>
        <td>130 ns</td>
        <td>1019 ns</td>
        <td>17978 ns</td>
        <td>242121 ns</td>
    </tr>
    <tr>
        <th>NDSort</th>
        <td>1499 ns</td>
        <td>27187 ns</td>
        <td>473078 ns</td>
        <td>4659433 ns</td>
    </tr>
</table>

<p>I did not measure space-use. The time of NDCycle for 10000 elements seems
suspicious - while it is not surprising, that in general it takes more time
than the naive approach, due to it&#39;s complexity, this jump is unexpected. Maybe
if I have the time I will investigate this and also measure memory use. In the
meantime, I
<a href="https://gist.github.com/Merovius/9e31f4dc6a42a78c1942">uploaded</a> all the
code used here, so you can try it out yourself. You can run it with <code>go run
perm.go</code> and run the benchmarks with <code>go test -bench Benchmark.*</code>.</p>

<!--

-->
</article>


          <div class="footer">
            <div class="contact">
              <p>
                Axel Wagner<br />
                Mathemematician, programmer, crazy person<br />
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/Merovius">github.com/Merovius</a><br />
				<a href="https://twitter.com/TheMerovius">@TheMerovius</a><br />
                <a href="https://plus.google.com/104026434400286502583">+Axel Wagner</a><br />
                <a href="/impressum.html">Impressum</a><br />
              </p>
            </div>
          </div>
        </div>
    </body>
</html>
